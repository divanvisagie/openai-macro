//! A simple example demonstrating the openai-macro workspace functionality.
//!
//! This example shows how to use the openai_impl macro to generate method implementations.
//! Run with: `cargo run --example simple`
//!
//! Note: You need to set OPENAI_API_KEY environment variable or run with OPENAI_OFFLINE=1
//! to use cached implementations only.

use openai_macro::openai_impl;

/// A simple trait for mathematical operations
trait Calculator {
    fn add(&self, a: i32, b: i32) -> i32;
    fn subtract(&self, a: i32, b: i32) -> i32;
    fn multiply(&self, a: i32, b: i32) -> i32;
    fn divide(&self, a: i32, b: i32) -> Option<i32>;
}

/// A basic calculator implementation
struct BasicCalculator;

#[openai_impl(
    model = "gpt-4o-mini",
    prompt = "Implement basic arithmetic operations. For division, return None if dividing by zero."
)]
impl Calculator for BasicCalculator {
    fn add(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by OpenAI
    }

    fn subtract(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by OpenAI
    }

    fn multiply(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by OpenAI
    }

    fn divide(&self, a: i32, b: i32) -> Option<i32> {
        // Implementation will be generated by OpenAI
    }
}

/// A trait for string operations
trait TextProcessor {
    fn uppercase(&self, text: &str) -> String;
    fn count_words(&self, text: &str) -> usize;
    fn reverse(&self, text: &str) -> String;
}

/// A text processor implementation
struct SimpleTextProcessor;

#[openai_impl(
    model = "gpt-4o-mini",
    prompt = "Implement string processing functions using standard library only"
)]
impl TextProcessor for SimpleTextProcessor {
    fn uppercase(&self, text: &str) -> String {
        // Implementation will be generated by OpenAI
    }

    fn count_words(&self, text: &str) -> usize {
        // Implementation will be generated by OpenAI
    }

    fn reverse(&self, text: &str) -> String {
        // Implementation will be generated by OpenAI
    }
}

fn main() {
    println!("OpenAI Macro Workspace Example");
    println!("==============================");

    // Test calculator
    let calc = BasicCalculator;
    println!("\nCalculator operations:");
    println!("5 + 3 = {}", calc.add(5, 3));
    println!("10 - 4 = {}", calc.subtract(10, 4));
    println!("6 * 7 = {}", calc.multiply(6, 7));
    println!("15 / 3 = {:?}", calc.divide(15, 3));
    println!("10 / 0 = {:?}", calc.divide(10, 0));

    // Test text processor
    let processor = SimpleTextProcessor;
    let text = "hello world rust programming";
    println!("\nText processing:");
    println!("Original: '{}'", text);
    println!("Uppercase: '{}'", processor.uppercase(text));
    println!("Word count: {}", processor.count_words(text));
    println!("Reversed: '{}'", processor.reverse(text));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculator() {
        let calc = BasicCalculator;

        // These will only pass if the AI generates correct implementations
        assert_eq!(calc.add(2, 3), 5);
        assert_eq!(calc.subtract(10, 4), 6);
        assert_eq!(calc.multiply(3, 4), 12);
        assert_eq!(calc.divide(8, 2), Some(4));
        assert_eq!(calc.divide(5, 0), None);
    }

    #[test]
    fn test_text_processor() {
        let processor = SimpleTextProcessor;
        let text = "hello world";

        assert_eq!(processor.uppercase(text), "HELLO WORLD");
        assert_eq!(processor.count_words(text), 2);
        assert_eq!(processor.reverse(text), "dlrow olleh");
    }
}
